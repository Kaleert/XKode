/*
 * Generated by CodeAnalyzer
 * Date: 2026-01-04 23:35:36
 * Total files: 32
 * Total lines: 2,313
 * Total size: 98,281 bytes (0.09 MB)
 * Estimated tokens: 23,675
 * TODO comments: 0
 * Improvement suggestions: 1
 */

/* server.js */

/* server.js */
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const pty = require('node-pty');
const fs = require('fs-extra');
const path = require('path');
const cors = require('cors');
const Client = require('ssh2-sftp-client');
const { v4: uuidv4 } = require('uuid');

const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: "*", methods: ["GET", "POST"] } });

app.use(express.json({ limit: '50mb' }));
app.use(cors());

// Static
const nodeModulesPath = path.join(__dirname, 'node_modules');
if (fs.existsSync(nodeModulesPath)) {
    app.use('/cdn/xterm', express.static(path.join(nodeModulesPath, 'xterm')));
    app.use('/cdn/fit', express.static(path.join(nodeModulesPath, 'xterm-addon-fit')));
}

// Storage Roots
const TERMUX_HOME = '/data/data/com.termux/files/home';
const homeRoot = fs.existsSync(TERMUX_HOME) ? TERMUX_HOME : process.env.HOME;
const connections = {
    'local-home': { type: 'local', root: homeRoot, name: 'Termux Home' }
};
if (fs.existsSync('/storage/emulated/0')) {
    connections['local-storage'] = { type: 'local', root: '/storage/emulated/0', name: 'Internal Storage' };
}

const getClient = (id) => connections[id] || connections['local-home'];

app.get('/api/ping', (req, res) => res.send('pong'));

app.get('/api/storages', (req, res) => {
    res.json(Object.keys(connections).map(id => ({ id, type: connections[id].type, name: connections[id].name })));
});

// CONNECT SFTP
app.post('/api/storages/connect-sftp', async (req, res) => {
    const sftp = new Client();
    try {
        console.log('SFTP Connecting to:', req.body.host);
        await sftp.connect(req.body);
        const id = `sftp-${uuidv4()}`;
        connections[id] = { type: 'sftp', client: sftp, root: '/', name: req.body.name || req.body.host };
        console.log('SFTP Connected, ID:', id);
        res.json({ id, name: connections[id].name, type: 'sftp' });
    } catch (e) { 
        console.error('SFTP Error:', e.message);
        res.status(500).json({ error: e.message }); 
    }
});

// LIST FILES
app.post('/api/fs/list', async (req, res) => {
    try {
        let { storageId, path: p } = req.body;
        const conn = getClient(storageId);
        
        if (conn.type === 'local') {
            let targetPath = conn.root;
            if (p && p !== '/') targetPath = path.join(conn.root, p.startsWith('/') ? p.slice(1) : p);
            
            if (!fs.existsSync(targetPath)) return res.json([]);
            try {
                const files = await fs.readdir(targetPath);
                const items = await Promise.all(files.map(async f => {
                    try {
                        const fullPath = path.join(targetPath, f);
                        const s = await fs.lstat(fullPath);
                        return { name: f, path: p === '/' ? `/${f}` : `${p}/${f}`, isDirectory: s.isDirectory() };
                    } catch { return null; }
                }));
                res.json(items.filter(Boolean).sort((a,b) => b.isDirectory - a.isDirectory));
            } catch (err) { res.json([{ name: 'Permission Denied', path: p, isDirectory: false }]); }
        } else {
            // SFTP
            const target = p || '/';
            console.log(`[SFTP] List: ${target}`);
            const list = await conn.client.list(target);
            const items = list.map(i => ({
                name: i.name, 
                path: target === '/' ? `/${i.name}` : `${target}/${i.name}`, 
                isDirectory: i.type === 'd'
            }));
            res.json(items.sort((a,b) => b.isDirectory - a.isDirectory));
        }
    } catch (e) { 
        console.error("FS List Error:", e.message);
        res.status(500).json({ error: e.message }); 
    }
});

// READ FILE
app.post('/api/fs/read', async (req, res) => {
    try {
        const { storageId, path: p } = req.body;
        const conn = getClient(storageId);
        
        if (conn.type === 'local') {
             const realPath = path.join(conn.root, p.startsWith('/') ? p.slice(1) : p);
             const stats = await fs.stat(realPath);
             if (stats.size > 2 * 1024 * 1024) return res.status(400).send("File too large (>2MB)");
             const content = await fs.readFile(realPath, 'utf8');
             res.send(content || "");
        } else {
             console.log(`[SFTP] Read: ${p}`);
             const buf = await conn.client.get(p);
             if (buf.length > 2 * 1024 * 1024) return res.status(400).send("File too large");
             res.send(buf.toString());
        }
    } catch (e) { res.status(500).send(e.message); }
});

// SAVE FILE
app.post('/api/fs/save', async (req, res) => {
    try {
        const { storageId, path: p, content } = req.body;
        const conn = getClient(storageId);
        if (conn.type === 'local') {
             const realPath = path.join(conn.root, p.startsWith('/') ? p.slice(1) : p);
             await fs.writeFile(realPath, content);
        } else {
             await conn.client.put(Buffer.from(content), p);
        }
        res.send('Saved');
    } catch (e) { res.status(500).send(e.message); }
});

// TERMINAL
const sessions = {};
io.on('connection', (socket) => {
    sessions[socket.id] = {};
    socket.on('term:create', (id) => {
        if (sessions[socket.id][id]) return;
        try {
            let shell = process.env.SHELL || 'bash';
            if (fs.existsSync('/data/data/com.termux/files/usr/bin/bash')) shell = '/data/data/com.termux/files/usr/bin/bash';
            const ptyProcess = pty.spawn(shell, [], { name: 'xterm-256color', cols: 80, rows: 30, cwd: homeRoot, env: process.env });
            sessions[socket.id][id] = ptyProcess;
            ptyProcess.onData(data => socket.emit('term:data', { id, data }));
            ptyProcess.onExit(() => { socket.emit('term:exit', { id }); if (sessions[socket.id]) delete sessions[socket.id][id]; });
        } catch (e) {}
    });
    socket.on('term:input', ({ id, data }) => sessions[socket.id]?.[id]?.write(data));
    socket.on('term:resize', ({ id, cols, rows }) => { try{sessions[socket.id]?.[id]?.resize(cols, rows)}catch(e){} });
    socket.on('term:kill', (id) => { sessions[socket.id]?.[id]?.kill(); delete sessions[socket.id][id]; });
    socket.on('disconnect', () => { if (sessions[socket.id]) { Object.values(sessions[socket.id]).forEach(p => {try{p.kill()}catch(e){}}); delete sessions[socket.id]; }});
});

server.listen(3000, '0.0.0.0', () => console.log('Server running on port 3000'));


/* App.js */

/* App.js */
import React, { useState, useRef, useEffect } from 'react';
import { 
  StyleSheet, View, Text, StatusBar, TouchableOpacity, 
  Modal, PanResponder, Keyboard, Platform, 
  LayoutAnimation, UIManager, Animated
} from 'react-native';
import { SafeAreaProvider, SafeAreaView } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Services
import NativeService from './src/services/NativeService';

// Components
import FileTree from './src/components/FileTree';
import Editor from './src/components/Editor';
import Terminal from './src/components/Terminal';
import AccessoryBar from './src/components/AccessoryBar';
import Tabs from './src/components/Tabs';
import Welcome from './src/components/Welcome';
import SftpManager from './src/components/SftpManager';
import Toast from './src/components/Toast';
import { isBinaryFile } from './src/utils/fileHelpers';

if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const CACHE_KEY = 'XKODE_CACHE';

export default function App() {
  const [isSidebarOpen, setSidebarOpen] = useState(false);
  const [openFiles, setOpenFiles] = useState([]);
  const [activeFileId, setActiveFileId] = useState(null);
  const [isTerminalVisible, setTerminalVisible] = useState(false);
  const [termHeight, setTermHeight] = useState(300);
  const [showSftp, setShowSftp] = useState(false);
  const [keyboardHeight, setKeyboardHeight] = useState(0);
  const [toast, setToast] = useState(null);

  const editorRef = useRef(null);
  const terminalRef = useRef(null);

  // --- UI LOGIC (FAB, Keyboard, Resize) ---
  const fabPan = useRef(new Animated.ValueXY()).current;
  const isDraggingFab = useRef(false);

  const fabResponder = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onPanResponderGrant: () => {
        isDraggingFab.current = false;
        fabPan.setOffset({ x: fabPan.x._value, y: fabPan.y._value });
        fabPan.setValue({ x: 0, y: 0 });
      },
      onPanResponderMove: (evt, g) => {
        if (Math.abs(g.dx) > 5 || Math.abs(g.dy) > 5) {
            isDraggingFab.current = true;
            Animated.event([null, { dx: fabPan.x, dy: fabPan.y }], { useNativeDriver: false })(evt, g);
        }
      },
      onPanResponderRelease: () => {
        fabPan.flattenOffset();
        if (!isDraggingFab.current) {
            LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
            setTerminalVisible(true);
        }
      }
    })
  ).current;

  const termPan = useRef(
    PanResponder.create({
      onMoveShouldSetPanResponder: (_, g) => Math.abs(g.dy) > 10,
      onPanResponderMove: (_, g) => {
        let h = termHeight - g.dy;
        if(h < 150) h = 150;
        if(h > 600) h = 600;
        setTermHeight(h);
      }
    })
  ).current;

  useEffect(() => {
    const showSub = Keyboard.addListener('keyboardDidShow', (e) => setKeyboardHeight(e.endCoordinates.height));
    const hideSub = Keyboard.addListener('keyboardDidHide', () => setKeyboardHeight(0));
    return () => { showSub.remove(); hideSub.remove(); };
  }, []);

  // --- PERSISTENCE ---
  useEffect(() => {
      AsyncStorage.getItem(CACHE_KEY).then(json => {
          if (json) {
              const data = JSON.parse(json);
              setOpenFiles(data.files || []);
              setActiveFileId(data.activeId);
          }
      });
  }, []);

  useEffect(() => {
      AsyncStorage.setItem(CACHE_KEY, JSON.stringify({ files: openFiles, activeId: activeFileId })).catch(()=>{});
  }, [openFiles, activeFileId]);

  const showToast = (message, type='info') => setToast({ message, type, id: Date.now() });

  // --- FILE OPERATIONS (VIA NATIVE MODULE) ---
  
  // ID файла = storageType + storageConfig + path
  const getUniqueId = (file) => `${file.storageType}::${file.path}`;

  const handleOpenFile = async (fileObj) => {
      // fileObj: { name, path, storageType, storageConfig (if sftp) }
      const uid = getUniqueId(fileObj);
      
      if (isBinaryFile(fileObj.name)) return showToast("Cannot open binary file", "error");

      if (openFiles.find(f => getUniqueId(f) === uid)) {
          setActiveFileId(uid);
          setSidebarOpen(false);
          return;
      }

      showToast("Reading...", "info");

      try {
          let content = "";
          
          if (fileObj.storageType === 'local') {
              content = await NativeService.readLocal(fileObj.path);
          } else if (fileObj.storageType === 'sftp') {
              // SFTP Read пока не реализован в моем Java примере выше, 
              // но если вы добавите метод readSftpFile в Java, вызовите его тут.
              // Пока заглушка:
              showToast("SFTP Reading not implemented in Java yet", "error");
              return; 
          }

          const newFile = { ...fileObj, content, isDirty: false };
          LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
          setOpenFiles(prev => [...prev, newFile]);
          setActiveFileId(uid);
          setSidebarOpen(false);
      } catch (e) { 
          showToast("Read Error: " + e.message, "error"); 
      }
  };

  const handleCloseFile = (uid) => {
      const newFiles = openFiles.filter(f => getUniqueId(f) !== uid);
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      setOpenFiles(newFiles);
      if (activeFileId === uid) {
          setActiveFileId(newFiles.length > 0 ? getUniqueId(newFiles[newFiles.length-1]) : null);
      }
  };

  const saveCurrentFile = async (content) => {
      const file = openFiles.find(f => getUniqueId(f) === activeFileId);
      if (!file) return;
      
      setOpenFiles(prev => prev.map(f => getUniqueId(f) === activeFileId ? { ...f, content, isDirty: false } : f));
      
      try {
          if (file.storageType === 'local') {
              await NativeService.saveLocal(file.path, content);
              showToast(`Saved ${file.name}`, "success");
          } else {
              showToast("SFTP Save not implemented yet", "error");
          }
      } catch (e) { showToast("Save Failed: " + e.message, "error"); }
  };

  const activeFileObj = openFiles.find(f => getUniqueId(f) === activeFileId);

  const handleAccessoryPress = (key, mods) => {
      const { ctrl, shift } = mods;
      if (isTerminalVisible && terminalRef.current) {
          terminalRef.current.handleInput(key, mods);
      } else if (editorRef.current) {
          if (key === 'TAB') editorRef.current.injectJavaScript(`window.insertText("\t")`);
          else if (key === 'SAVE') editorRef.current.injectJavaScript(`window.requestSave()`);
          else if (key.length === 1) {
              const text = shift ? key.toUpperCase() : key;
              editorRef.current.injectJavaScript(`window.insertText("${text}")`);
          }
      }
  };

  const sidebarX = useRef(new Animated.Value(-280)).current;
  useEffect(() => {
      Animated.timing(sidebarX, { toValue: isSidebarOpen ? 0 : -280, duration: 250, useNativeDriver: true }).start();
  }, [isSidebarOpen]);

  return (
    <SafeAreaProvider>
      <SafeAreaView style={styles.container} edges={['top', 'left', 'right']}>
        <StatusBar barStyle="light-content" backgroundColor="#1e1e1e" />
        {toast && <Toast message={toast.message} type={toast.type} onHide={() => setToast(null)} />}

        {/* HEADER */}
        <View style={styles.header}>
            <TouchableOpacity onPress={() => setSidebarOpen(!isSidebarOpen)} style={styles.iconBtn}>
                <MaterialCommunityIcons name={isSidebarOpen ? "close" : "menu"} size={26} color="#007acc" />
            </TouchableOpacity>
            <View style={{flex: 1, marginLeft: 10}}>
                <Text style={styles.appName} numberOfLines={1}>
                    {activeFileObj ? activeFileObj.name : 'XKode'} {activeFileObj?.isDirty ? '●' : ''}
                </Text>
                {activeFileObj && <Text style={styles.pathText} numberOfLines={1}>{activeFileObj.path}</Text>}
            </View>
            <TouchableOpacity onPress={() => editorRef.current?.injectJavaScript('window.requestSave()')} style={styles.iconBtn}>
                <MaterialCommunityIcons name="content-save" size={24} color={activeFileObj?.isDirty ? "#e6b450" : "#ccc"} />
            </TouchableOpacity>
        </View>

        <View style={styles.workspace}>
            {/* EDITOR */}
            <View style={{flex: 1}}>
                {openFiles.length > 0 && (
                    <Tabs files={openFiles.map(f => ({...f, id: getUniqueId(f)}))} activeFile={activeFileId} onTabClick={setActiveFileId} onCloseTab={handleCloseFile} />
                )}
                <View style={{flex: 1}}>
                    {activeFileObj ? (
                        <Editor ref={editorRef} initialCode={activeFileObj.content} path={activeFileObj.path} onSave={saveCurrentFile} />
                    ) : <Welcome onOpenFile={() => setSidebarOpen(true)} />}
                </View>
                <View style={{height: isTerminalVisible ? 0 : 90}} />
            </View>

            {/* SIDEBAR */}
            <Animated.View style={[styles.sidebarOverlay, { transform: [{ translateX: sidebarX }] }]}>
                <FileTree 
                    onSelectFile={handleOpenFile} 
                    onAddSftp={() => setShowSftp(true)} 
                />
                <TouchableOpacity style={styles.shadowStrip} onPress={() => setSidebarOpen(false)} />
            </Animated.View>

            {/* KEYBOARD + TERMINAL */}
            <View style={[styles.keyboardLayer, { bottom: keyboardHeight }]}>
                <View style={[styles.terminalWrapper, { height: termHeight, display: isTerminalVisible ? 'flex' : 'none' }]}>
                     <View style={styles.resizeHandle} {...termPan.panHandlers}><View style={styles.resizeBar} /></View>
                     <Terminal 
                        ref={terminalRef} 
                        onClose={() => setTerminalVisible(false)}
                        onMinimize={() => setTerminalVisible(false)} 
                     />
                </View>
                <AccessoryBar onPress={handleAccessoryPress} />
            </View>
        </View>

        {!isTerminalVisible && (
            <Animated.View style={[styles.fab, { transform: fabPan.getTranslateTransform() }]} {...fabResponder.panHandlers}>
                <MaterialCommunityIcons name="console-line" size={20} color="white" />
            </Animated.View>
        )}

        <Modal visible={showSftp} animationType="slide">
            <SafeAreaView style={{flex:1, backgroundColor:'#1e1e1e'}}>
                <SftpManager onConnect={() => setShowSftp(false)} onClose={() => setShowSftp(false)} />
            </SafeAreaView>
        </Modal>
      </SafeAreaView>
    </SafeAreaProvider>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#1e1e1e' },
  header: { height: 55, backgroundColor: '#252526', flexDirection: 'row', alignItems: 'center', paddingHorizontal: 5, elevation: 4, zIndex: 50 },
  appName: { color: '#ccc', fontWeight: 'bold', fontSize: 16 },
  pathText: { color: '#666', fontSize: 10 },
  iconBtn: { padding: 8 },
  workspace: { flex: 1, backgroundColor: '#1e1e1e', position: 'relative' },
  sidebarOverlay: { position: 'absolute', top: 0, bottom: 0, left: 0, width: 280, flexDirection: 'row', backgroundColor: '#252526', zIndex: 100, elevation: 20 },
  shadowStrip: { width: 40, height:'100%' }, // Invisible hit area to close
  keyboardLayer: { position: 'absolute', left: 0, right: 0, zIndex: 60, backgroundColor: '#1e1e1e' },
  terminalWrapper: { borderTopWidth: 1, borderTopColor: '#007acc', backgroundColor: '#1e1e1e', overflow: 'hidden' },
  resizeHandle: { height: 20, backgroundColor: '#252526', justifyContent: 'center', alignItems: 'center' },
  resizeBar: { width: 40, height: 4, backgroundColor: '#555', borderRadius: 2 },
  fab: { position: 'absolute', right: 20, bottom: 100, width: 48, height: 48, borderRadius: 24, backgroundColor: '#007acc', justifyContent: 'center', alignItems: 'center', elevation: 6, zIndex: 200, borderWidth: 1, borderColor: 'rgba(255,255,255,0.3)' }
});


/* npm */



/* src/components/Terminal.js */

/* src/components/Terminal.js */
import React, { useRef, useState, forwardRef, useImperativeHandle, useEffect } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Modal, TextInput } from 'react-native';
import WebView from 'react-native-webview'; 
import { MaterialCommunityIcons } from '@expo/vector-icons';
import NativeService from '../services/NativeService';

const Terminal = forwardRef(({ onClose, onMinimize }, ref) => {
  const [showConfig, setShowConfig] = useState(false);
  const [sshConfig, setSshConfig] = useState({ host: '127.0.0.1', port: '8022', user: 'root', pass: 'password' });
  const [isConnected, setIsConnected] = useState(false);
  
  const webviewRef = useRef(null);

  useImperativeHandle(ref, () => ({
    handleInput: (key, mods) => {
        let char = key;
        const { ctrl } = mods;
        if (ctrl) {
            if (key === 'C') char = '\x03';
            // ... (остальные коды)
        }
        NativeService.writeSSH(char);
    }
  }));

  useEffect(() => {
      const sub = NativeService.onSSHOutput((data) => {
          // Экранируем спецсимволы JSON перед отправкой в JS
          const safeData = JSON.stringify(data);
          webviewRef.current?.injectJavaScript(`window.term.write(${safeData})`);
      });
      return () => {
          sub.remove();
          NativeService.disconnectSSH();
      };
  }, []);

  const connect = async () => {
      setShowConfig(false);
      try {
          webviewRef.current?.injectJavaScript(`window.term.reset(); window.term.write('Connecting to ${sshConfig.host}...');`);
          const res = await NativeService.connectSSH(sshConfig.host, sshConfig.port, sshConfig.user, sshConfig.pass);
          setIsConnected(true);
          webviewRef.current?.injectJavaScript(`window.term.write('\\r\\nConnected!\\r\\n');`);
      } catch (e) {
          webviewRef.current?.injectJavaScript(`window.term.write('\\r\\nError: ${e.message}\\r\\n');`);
      }
  };

  // HTML для xterm.js (берется локально или с CDN)
  // ВАЖНО: В реальном APK файлы xterm лучше положить в android/app/src/main/assets
  // и грузить как file:///android_asset/... 
  // Но для примера используем CDN, т.к. "полный код" ассетов я не могу впихнуть.
  const html = `
    <!DOCTYPE html>
    <html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
        <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
        <style>body { margin: 0; background: #1e1e1e; overflow: hidden; }</style>
    </head>
    <body>
        <div id="terminal" style="width: 100vw; height: 100vh;"></div>
        <script>
            var term = new Terminal({
                fontFamily: 'monospace', fontSize: 14, cursorBlink: true,
                theme: { background: '#1e1e1e' }
            });
            var fit = new FitAddon.FitAddon();
            term.loadAddon(fit);
            term.open(document.getElementById('terminal'));
            fit.fit();
            
            window.term = term;
            
            // Отправка ввода обратно в React Native -> Java
            // (В этом примере мы используем React Native Bridge, 
            // поэтому нам нужно посылать postMessage, но так как ввод перехватывает App.js 
            // через AccessoryBar, здесь мы можем слушать только нажатия по самому WebView)
            // Но лучше полагаться на AccessoryBar для ввода.
            
            window.addEventListener('resize', () => fit.fit());
        </script>
    </body>
    </html>
  `;

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={{color:'#aaa', flex:1, marginLeft:10}}>SSH Terminal</Text>
        <TouchableOpacity onPress={() => setShowConfig(true)} style={styles.btn}><MaterialCommunityIcons name="cog" size={18} color="#ccc"/></TouchableOpacity>
        <TouchableOpacity onPress={onMinimize} style={styles.btn}><MaterialCommunityIcons name="minus" size={18} color="#ccc"/></TouchableOpacity>
        <TouchableOpacity onPress={onClose} style={styles.btn}><MaterialCommunityIcons name="close" size={18} color="#f44"/></TouchableOpacity>
      </View>

      <WebView
        ref={webviewRef}
        source={{ html }}
        style={{ flex: 1, backgroundColor: '#1e1e1e' }}
        javaScriptEnabled={true}
      />

      <Modal visible={showConfig} transparent animationType="fade">
          <View style={styles.modalBg}>
              <View style={styles.modal}>
                  <Text style={styles.modalTitle}>SSH Connection</Text>
                  <TextInput style={styles.input} value={sshConfig.host} onChangeText={t=>setSshConfig({...sshConfig, host:t})} placeholder="Host (127.0.0.1)"/>
                  <TextInput style={styles.input} value={sshConfig.port} onChangeText={t=>setSshConfig({...sshConfig, port:t})} placeholder="Port (8022)"/>
                  <TextInput style={styles.input} value={sshConfig.user} onChangeText={t=>setSshConfig({...sshConfig, user:t})} placeholder="Username"/>
                  <TextInput style={styles.input} value={sshConfig.pass} onChangeText={t=>setSshConfig({...sshConfig, pass:t})} placeholder="Password" secureTextEntry/>
                  <TouchableOpacity style={styles.connectBtn} onPress={connect}><Text style={{color:'white'}}>Connect</Text></TouchableOpacity>
              </View>
          </View>
      </Modal>
    </View>
  );
});

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#1e1e1e' },
  header: { height: 35, flexDirection: 'row', alignItems: 'center', backgroundColor: '#252526', borderBottomWidth: 1, borderBottomColor: '#333' },
  btn: { padding: 8 },
  modalBg: { flex: 1, backgroundColor: 'rgba(0,0,0,0.7)', justifyContent: 'center', padding: 20 },
  modal: { backgroundColor: '#333', padding: 20, borderRadius: 10 },
  modalTitle: { color: 'white', fontWeight: 'bold', marginBottom: 10 },
  input: { backgroundColor: '#222', color: 'white', marginBottom: 10, padding: 8, borderRadius: 5 },
  connectBtn: { backgroundColor: '#007acc', padding: 10, alignItems: 'center', borderRadius: 5 }
});

export default Terminal;


/* src/components/FileTree.js */

/* src/components/FileTree.js */
import React, { useState, useEffect } from 'react';
import { View, Text, FlatList, TouchableOpacity, StyleSheet, ActivityIndicator, LayoutAnimation } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import AsyncStorage from '@react-native-async-storage/async-storage';
import NativeService from '../services/NativeService';
import FileIcon from './FileIcon';

// Начальный экран - список хранилищ
const ROOT_STORAGES = [
    { name: 'Internal Storage', path: '/', type: 'local', icon: 'cellphone' }
];

export default function FileTree({ onSelectFile, onAddSftp }) {
  const [nodes, setNodes] = useState([]); 
  const [history, setHistory] = useState([]); // Array of { path, type, config }
  const [currentLocation, setCurrentLocation] = useState(null); // null = Root Storages list
  const [loading, setLoading] = useState(false);
  const [sftpProfiles, setSftpProfiles] = useState([]);

  useEffect(() => {
      loadSftpProfiles();
      // Тут можно добавить восстановление последнего пути
      loadStorages();
  }, []);

  const loadSftpProfiles = async () => {
      try {
          const json = await AsyncStorage.getItem('SFTP_PROFILES');
          if (json) setSftpProfiles(JSON.parse(json));
      } catch(e) {}
  };

  const loadStorages = () => {
      setLoading(false);
      setCurrentLocation(null);
      // Объединяем локальные и SFTP профили
      const sftpNodes = sftpProfiles.map(p => ({ 
          name: p.name || p.host, 
          path: '/', 
          type: 'sftp', 
          config: p,
          icon: 'server-network' 
      }));
      setNodes([...ROOT_STORAGES, ...sftpNodes]);
  };

  const loadFiles = async (location) => {
      setLoading(true);
      setCurrentLocation(location);
      try {
          let list = [];
          if (location.type === 'local') {
              list = await NativeService.listLocal(location.path);
          } else if (location.type === 'sftp') {
              list = await NativeService.listSftp(location.config, location.path);
          }
          
          LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
          // Сортировка: папки сверху
          setNodes(list.sort((a,b) => b.isDirectory - a.isDirectory));
      } catch (e) {
          console.warn(e);
          // Если ошибка, возвращаемся назад
          goBack();
      } finally { setLoading(false); }
  };

  const handlePress = (item) => {
      if (currentLocation === null) {
          // Мы в корне, нажали на хранилище
          const newLoc = { 
              type: item.type, 
              path: item.path, 
              config: item.config, 
              storageName: item.name 
          };
          setHistory([...history, null]);
          loadFiles(newLoc);
      } else if (item.isDirectory) {
          // Мы внутри, нажали на папку
          const newLoc = { ...currentLocation, path: item.path };
          setHistory([...history, currentLocation]);
          loadFiles(newLoc);
      } else {
          // Нажали на файл
          onSelectFile({ 
              name: item.name, 
              path: item.path, 
              storageType: currentLocation.type, 
              storageConfig: currentLocation.config 
          });
      }
  };

  const goBack = () => {
      if (history.length === 0) return;
      const prev = history[history.length - 1];
      setHistory(history.slice(0, -1));
      
      if (prev === null) loadStorages();
      else loadFiles(prev);
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
          <Text style={styles.title}>FILES</Text>
          <TouchableOpacity onPress={() => { loadSftpProfiles(); onAddSftp(); }}>
              <MaterialCommunityIcons name="plus" size={20} color="#ccc" />
          </TouchableOpacity>
      </View>

      {currentLocation && (
          <TouchableOpacity style={styles.backBtn} onPress={goBack}>
              <MaterialCommunityIcons name="arrow-left" size={16} color="#ccc" />
              <Text style={styles.backText} numberOfLines={1}>
                  {currentLocation.storageName}: {currentLocation.path === '/' ? 'Root' : '..'}
              </Text>
          </TouchableOpacity>
      )}

      {loading ? (
          <ActivityIndicator size="small" color="#007acc" style={{marginTop: 20}}/>
      ) : (
          <FlatList 
            data={nodes} 
            renderItem={({item}) => (
                <TouchableOpacity style={styles.item} onPress={() => handlePress(item)}>
                    {currentLocation === null ? (
                        <MaterialCommunityIcons name={item.icon} size={20} color="#007acc" style={{marginRight: 8}} />
                    ) : (
                        <FileIcon name={item.name} isDirectory={item.isDirectory} style={{marginRight: 8}} />
                    )}
                    <Text style={styles.itemText} numberOfLines={1}>{item.name}</Text>
                </TouchableOpacity>
            )}
            keyExtractor={(item, i) => i.toString()}
            contentContainerStyle={{paddingBottom: 20}}
            style={{flex: 1, width: '100%'}}
          />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, width: '100%', backgroundColor: '#252526' },
  header: { flexDirection: 'row', justifyContent:'space-between', padding: 10, borderBottomWidth: 1, borderBottomColor: '#333' },
  title: { color: '#bbb', fontWeight: 'bold', fontSize: 12 },
  item: { flexDirection: 'row', alignItems: 'center', height: 40, paddingHorizontal: 10, width: '100%' },
  itemText: { color: '#ccc', fontSize: 14, flex: 1 },
  backBtn: { flexDirection: 'row', alignItems: 'center', padding: 8, backgroundColor: '#2d2d2d', borderBottomWidth: 1, borderBottomColor: '#333' },
  backText: { color: '#fff', marginLeft: 10, fontSize: 12, fontWeight: 'bold' }
});


/* src/components/Editor.js */

/* src/components/Editor.js */
import React, { forwardRef, useEffect } from 'react';
import { View, StyleSheet } from 'react-native';
import WebView from 'react-native-webview';

const Editor = forwardRef(({ initialCode, path, onSave }, ref) => {
  
  useEffect(() => {
    if (ref.current) {
        const safeCode = typeof initialCode === 'string' ? initialCode : '';
        // Небольшая задержка для гарантии загрузки WebView
        setTimeout(() => {
            const payload = JSON.stringify({ type: 'setCode', content: safeCode, path: path });
            ref.current.postMessage(payload);
        }, 100);
    }
  }, [initialCode, path]);

  const htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #1e1e1e; }
        #container { width: 100vw; height: 100vh; }
        /* Умеренный отступ снизу */
        .monaco-editor .lines-content { padding-bottom: 300px !important; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
</head>
<body>
    <div id="container"></div>
    <script>
        require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' }});
        require(['vs/editor/editor.main'], function() {
            window.editor = monaco.editor.create(document.getElementById('container'), {
                value: "",
                language: 'javascript',
                theme: 'vs-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                fontSize: 14,
                lineNumbers: 'on',
                lineNumbersMinChars: 3, // Компактные номера
                glyphMargin: false, // Убираем отступ слева
                folding: true,
                scrollBeyondLastLine: false,
                wordWrap: 'off', // Выключаем перенос строк по требованию
                scrollbar: {
                    verticalScrollbarSize: 10,
                    horizontalScrollbarSize: 10
                }
            });

            document.addEventListener("message", function(event) {
                try {
                    var data = JSON.parse(event.data);
                    if (data.type === 'setCode') {
                         var ext = data.path ? data.path.split('.').pop() : 'js';
                         var lang = 'javascript';
                         if(ext === 'html') lang = 'html';
                         if(ext === 'css') lang = 'css';
                         if(ext === 'json') lang = 'json';
                         if(ext === 'py') lang = 'python';
                         if(ext === 'java') lang = 'java';
                         if(ext === 'cpp') lang = 'cpp';
                         
                         var model = window.editor.getModel();
                         monaco.editor.setModelLanguage(model, lang);
                         window.editor.setValue(data.content);
                    }
                } catch(e) {}
            });
        });

        window.requestSave = function() {
            if(window.editor) window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'save', content: window.editor.getValue() }));
        };
        
        window.insertText = function(text) {
            if (window.editor) {
                var selection = window.editor.getSelection();
                var op = {identifier: {major:1, minor:1}, range: selection, text: text, forceMoveMarkers: true};
                window.editor.executeEdits("my-source", [op]);
                window.editor.focus();
            }
        };
    </script>
</body>
</html>
  `;

  return (
    <View style={styles.container}>
      <WebView
        ref={ref}
        originWhitelist={['*']}
        source={{ html: htmlContent }}
        style={{ flex: 1, backgroundColor: '#1e1e1e' }}
        onMessage={(e) => {
            try {
                const data = JSON.parse(e.nativeEvent.data);
                if (data.type === 'save') onSave(data.content);
            } catch(err){}
        }}
        androidLayerType="hardware"
        hideKeyboardAccessoryView={true}
      />
    </View>
  );
});

const styles = StyleSheet.create({ container: { flex: 1, backgroundColor: '#1e1e1e' } });
export default Editor;


/* src/components/AccessoryBar.js */

/* src/components/AccessoryBar.js */
import React, { useState, useMemo } from 'react';
import { View, Text, TouchableOpacity, ScrollView, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

// Ряд 1: Управление (17 кнопок)
const ROW1 = [
    { t: 'CTRL', type: 'mod' }, { t: 'SHIFT', type: 'mod' },
    { t: 'TAB', icon: 'keyboard-tab' }, { t: 'ESC' },
    { t: 'LEFT', icon: 'arrow-left' }, { t: 'DOWN', icon: 'arrow-down' }, 
    { t: 'UP', icon: 'arrow-up' }, { t: 'RIGHT', icon: 'arrow-right' },
    { t: 'PASTE', icon: 'content-paste' }, { t: 'UNDO', icon: 'undo' }, 
    { t: 'REDO', icon: 'redo' }, { t: 'SAVE', icon: 'content-save' },
    { t: 'SEARCH', icon: 'magnify' }, { t: 'HOME', icon: 'chevron-double-left' },
    { t: 'END', icon: 'chevron-double-right' }, { t: 'PGUP', icon: 'arrow-collapse-up' },
    { t: 'PGDN', icon: 'arrow-collapse-down' }
];

// Ряд 2: Символы (17 кнопок - выровнял количество)
const ROW2 = [
    '{', '}', '(', ')', '[', ']', '=', '=>', ';', ':', 
    '.', ',', '"', "'", '`', '<', '>'
];

// Добиваем второй ряд, если не хватает, или создаем пары
const createPairs = () => {
    const pairs = [];
    const max = Math.max(ROW1.length, ROW2.length);
    for(let i=0; i<max; i++) {
        pairs.push({ top: ROW1[i] || null, bottom: ROW2[i] || null });
    }
    return pairs;
};

export default function AccessoryBar({ onPress }) {
  const [isCtrl, setIsCtrl] = useState(false);
  const [isShift, setIsShift] = useState(false);
  
  const pairs = useMemo(() => createPairs(), []);

  const handlePress = (key) => {
      if (!key) return;
      if (key === 'CTRL') { setIsCtrl(!isCtrl); return; }
      if (key === 'SHIFT') { setIsShift(!isShift); return; }
      
      onPress(key, { ctrl: isCtrl, shift: isShift });
      if (isShift) setIsShift(false);
  };

  const KeyBtn = ({ item, height }) => {
      if (!item) return <View style={[styles.key, { height, backgroundColor: 'transparent', borderWidth: 0 }]} />;
      
      const t = typeof item === 'object' ? item.t : item;
      const icon = typeof item === 'object' ? item.icon : null;
      
      let bg = '#2d2d2d';
      let color = '#ccc';
      if (t === 'CTRL' && isCtrl) { bg = '#007acc'; color = 'white'; }
      if (t === 'SHIFT' && isShift) { bg = '#007acc'; color = 'white'; }

      return (
          <TouchableOpacity 
            style={[styles.key, { height, backgroundColor: bg }]} 
            onPress={() => handlePress(t)}
            activeOpacity={0.6}
          >
              {icon ? <MaterialCommunityIcons name={icon} size={20} color={color} /> : 
                      <Text style={[styles.keyText, {color}]}>{t}</Text>}
          </TouchableOpacity>
      );
  };

  return (
    <View style={styles.container}>
      <ScrollView 
        horizontal 
        showsHorizontalScrollIndicator={false} 
        keyboardShouldPersistTaps="always"
        contentContainerStyle={styles.scrollContent}
      >
          {pairs.map((pair, i) => (
              <View key={i} style={styles.column}>
                  <KeyBtn item={pair.top} height={38} />
                  <KeyBtn item={pair.bottom} height={38} />
              </View>
          ))}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
      height: 86, // 38 + 38 + отступы
      backgroundColor: '#202020', 
      borderTopWidth: 1, 
      borderTopColor: '#333' 
  },
  scrollContent: {
      paddingHorizontal: 2,
      paddingVertical: 3
  },
  column: {
      flexDirection: 'column',
      marginHorizontal: 1,
      justifyContent: 'space-between',
      height: '100%' // Растягиваем на всю высоту контейнера
  },
  key: { 
      minWidth: 44, 
      justifyContent: 'center', 
      alignItems: 'center', 
      borderRadius: 4,
      marginBottom: 2 // Отступ между верхним и нижним рядом
  },
  keyText: { 
      fontWeight: 'bold', 
      fontSize: 16, 
      fontFamily: 'monospace' 
  }
});


/* src/components/FileIcon.js */

import React from 'react';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { fileConfig } from '../config/fileConfig';

export default function FileIcon({ name, isDirectory, isOpen, style }) {
  let iconData;

  if (isDirectory) {
    const specific = fileConfig.folderIcons[name.toLowerCase()];
    if (specific) {
        iconData = specific;
    } else {
        iconData = isOpen ? fileConfig.folderIcons.open : fileConfig.folderIcons.default;
    }
  } else {
    iconData = fileConfig.getFileSettings(name);
  }

  return (
    <MaterialCommunityIcons 
      name={iconData.icon} 
      size={20} 
      color={iconData.color} 
      style={style}
    />
  );
}


/* src/components/Tabs.js */

/* src/components/Tabs.js */
import React from 'react';
import { View, Text, TouchableOpacity, ScrollView, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import FileIcon from './FileIcon';

export default function Tabs({ files, activeFile, onTabClick, onCloseTab }) {
  return (
    <View style={styles.container}>
      <ScrollView horizontal showsHorizontalScrollIndicator={false}>
        {files.map(file => {
          const isActive = file.id === activeFile;
          return (
            <TouchableOpacity 
              key={file.id}
              style={[styles.tab, isActive && styles.activeTab]}
              onPress={() => onTabClick(file.id)}
              activeOpacity={0.8}
            >
              <FileIcon name={file.name} style={{ marginRight: 6 }} />
              <Text style={[styles.text, isActive && styles.activeText]}>
                {file.name}{file.isDirty ? ' •' : ''}
              </Text>
              <TouchableOpacity onPress={(e) => { e.stopPropagation(); onCloseTab(file.id); }} style={styles.closeBtn}>
                <MaterialCommunityIcons name="close" size={16} color={isActive ? "#fff" : "#777"} />
              </TouchableOpacity>
            </TouchableOpacity>
          );
        })}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { height: 38, backgroundColor: '#1e1e1e', borderBottomWidth: 1, borderBottomColor: '#333' },
  tab: {
    flexDirection: 'row', alignItems: 'center', paddingHorizontal: 10,
    backgroundColor: '#252526', borderRightWidth: 1, borderRightColor: '#1e1e1e',
    height: '100%', maxWidth: 200
  },
  activeTab: { backgroundColor: '#1e1e1e', borderTopWidth: 2, borderTopColor: '#007acc' },
  text: { color: '#888', fontSize: 13, marginRight: 8 },
  activeText: { color: '#fff' },
  closeBtn: { padding: 4 }
});


/* src/components/Welcome.js */

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Image } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

export default function Welcome({ onOpenFile }) {
  return (
    <View style={styles.container}>
      <MaterialCommunityIcons name="code-braces" size={80} color="#333" style={{marginBottom: 20}} />
      <Text style={styles.title}>Termux IDE</Text>
      <Text style={styles.subtitle}>Editing evolved.</Text>

      <View style={styles.actions}>
          <TouchableOpacity style={styles.btn} onPress={onOpenFile}>
              <Text style={styles.link}>Show All Commands</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.btn} onPress={onOpenFile}>
              <Text style={styles.link}>Go to File...</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.btn} onPress={onOpenFile}>
              <Text style={styles.link}>Open File/Folder</Text>
          </TouchableOpacity>
      </View>

      <View style={styles.recent}>
          <Text style={styles.recentTitle}>Recent</Text>
          <Text style={{color: '#555', fontStyle: 'italic'}}>No recent files</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#1e1e1e', alignItems: 'center', justifyContent: 'center', paddingBottom: 50 },
  title: { color: '#ccc', fontSize: 24, fontWeight: 'bold', marginBottom: 5 },
  subtitle: { color: '#666', fontSize: 16, marginBottom: 40 },
  actions: { width: '100%', maxWidth: 300, alignItems: 'flex-start' },
  btn: { marginBottom: 10 },
  link: { color: '#007acc', fontSize: 16 },
  recent: { marginTop: 40, width: '100%', maxWidth: 300 },
  recentTitle: { color: '#ccc', marginBottom: 10, fontSize: 14 }
});


/* src/components/SftpManager.js */

/* src/components/SftpManager.js */
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, TouchableOpacity, FlatList, StyleSheet } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { MaterialCommunityIcons } from '@expo/vector-icons';

export default function SftpManager({ onClose, onConnect }) {
    const [profiles, setProfiles] = useState([]);
    const [host, setHost] = useState('');
    const [user, setUser] = useState('');
    const [pass, setPass] = useState('');
    const [port, setPort] = useState('22');

    useEffect(() => {
        AsyncStorage.getItem('SFTP_PROFILES').then(j => j && setProfiles(JSON.parse(j)));
    }, []);

    const save = () => {
        const newP = { host, user, password: pass, port, name: `${user}@${host}` };
        const updated = [...profiles, newP];
        setProfiles(updated);
        AsyncStorage.setItem('SFTP_PROFILES', JSON.stringify(updated));
        // Reset form
        setHost(''); setUser(''); setPass('');
    };

    return (
        <View style={{flex:1, padding: 20}}>
            <Text style={{color:'white', fontSize:20, marginBottom:20}}>SFTP Profiles</Text>
            <View>
                <TextInput style={styles.input} placeholder="Host" placeholderTextColor="#666" value={host} onChangeText={setHost}/>
                <TextInput style={styles.input} placeholder="User" placeholderTextColor="#666" value={user} onChangeText={setUser}/>
                <TextInput style={styles.input} placeholder="Password" placeholderTextColor="#666" secureTextEntry value={pass} onChangeText={setPass}/>
                <TouchableOpacity style={styles.btn} onPress={save}><Text style={{color:'white'}}>Save Profile</Text></TouchableOpacity>
            </View>
            
            <FlatList 
                data={profiles}
                keyExtractor={(i,x) => x.toString()}
                renderItem={({item}) => (
                    <View style={styles.item}>
                        <Text style={{color:'white'}}>{item.name}</Text>
                        <TouchableOpacity onPress={() => {
                            // Удаление
                            const n = profiles.filter(p => p !== item);
                            setProfiles(n);
                            AsyncStorage.setItem('SFTP_PROFILES', JSON.stringify(n));
                        }}>
                            <MaterialCommunityIcons name="delete" size={20} color="#f44" />
                        </TouchableOpacity>
                    </View>
                )}
            />
            <TouchableOpacity onPress={onClose} style={{marginTop:20}}><Text style={{color:'#aaa'}}>Close</Text></TouchableOpacity>
        </View>
    );
}

const styles = StyleSheet.create({
    input: { backgroundColor:'#252526', color:'white', marginBottom:10, padding:10, borderRadius:5 },
    btn: { backgroundColor: '#007acc', padding:10, alignItems:'center', borderRadius:5, marginBottom:20 },
    item: { flexDirection:'row', justifyContent:'space-between', padding:15, backgroundColor:'#333', marginBottom:5, borderRadius:5 }
});


/* src/components/StorageManager.js */

import React, { useState } from 'react';
import { View, Text, TouchableOpacity, FlatList, StyleSheet, Modal, TextInput, Alert } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import axios from 'axios';

export default function StorageManager({ serverUrl, storages, onSelect, onRefresh }) {
  const [showAddMenu, setShowAddMenu] = useState(false);
  const [showForm, setShowForm] = useState(null); // 'sftp' | 'ftp' ...
  const [config, setConfig] = useState({ host: '', user: '', password: '', port: '22', name: '' });

  const connectSftp = async () => {
      try {
          await axios.post(`${serverUrl}/api/storages/connect-sftp`, config);
          setShowForm(null);
          onRefresh(); // Обновляем список
      } catch (e) {
          Alert.alert("Error", e.message);
      }
  };

  const renderItem = ({ item }) => (
    <TouchableOpacity style={styles.item} onPress={() => onSelect(item)}>
        <MaterialCommunityIcons 
            name={item.type === 'local' ? 'cellphone' : 'server-network'} 
            size={24} color={item.type === 'local' ? '#dcb67a' : '#007acc'} 
        />
        <View style={{marginLeft: 15, flex: 1}}>
            <Text style={styles.itemName}>{item.name}</Text>
            <Text style={styles.itemSub}>{item.type.toUpperCase()}</Text>
        </View>
        <MaterialCommunityIcons name="chevron-right" size={20} color="#666" />
    </TouchableOpacity>
  );

  return (
    <View style={styles.container}>
        <Text style={styles.header}>Storage Manager</Text>
        
        <FlatList 
            data={storages}
            renderItem={renderItem}
            keyExtractor={i => i.id}
            contentContainerStyle={{padding: 10}}
        />

        {/* FAB для добавления */}
        <View style={styles.fabContainer}>
            {showAddMenu && (
                <View style={styles.menu}>
                    <TouchableOpacity style={styles.menuItem} onPress={() => setShowForm('sftp')}>
                        <MaterialCommunityIcons name="server-security" size={20} color="#fff"/>
                        <Text style={styles.menuText}>SFTP</Text>
                    </TouchableOpacity>
                    <TouchableOpacity style={styles.menuItem}>
                        <MaterialCommunityIcons name="web" size={20} color="#ccc"/>
                        <Text style={styles.menuText}>FTP (Soon)</Text>
                    </TouchableOpacity>
                </View>
            )}
            <TouchableOpacity 
                style={[styles.fab, {backgroundColor: showAddMenu ? '#444' : '#007acc'}]}
                onPress={() => setShowAddMenu(!showAddMenu)}
            >
                <MaterialCommunityIcons name="plus" size={24} color="white" />
            </TouchableOpacity>
        </View>

        {/* MODAL FORM */}
        <Modal visible={!!showForm} transparent animationType="slide">
            <View style={styles.modalBg}>
                <View style={styles.modal}>
                    <Text style={styles.modalTitle}>Add {showForm?.toUpperCase()}</Text>
                    <TextInput placeholder="Name (Optional)" placeholderTextColor="#666" style={styles.input} onChangeText={t=>setConfig({...config, name:t})}/>
                    <TextInput placeholder="Host" placeholderTextColor="#666" style={styles.input} onChangeText={t=>setConfig({...config, host:t})}/>
                    <TextInput placeholder="Port" placeholderTextColor="#666" style={styles.input} defaultValue="22" onChangeText={t=>setConfig({...config, port:t})}/>
                    <TextInput placeholder="Username" placeholderTextColor="#666" style={styles.input} onChangeText={t=>setConfig({...config, user:t})}/>
                    <TextInput placeholder="Password" placeholderTextColor="#666" style={styles.input} secureTextEntry onChangeText={t=>setConfig({...config, password:t})}/>
                    
                    <View style={styles.actions}>
                        <TouchableOpacity onPress={() => setShowForm(null)}><Text style={{color:'#ccc'}}>Cancel</Text></TouchableOpacity>
                        <TouchableOpacity onPress={connectSftp}><Text style={{color:'#007acc', fontWeight:'bold'}}>Connect</Text></TouchableOpacity>
                    </View>
                </View>
            </View>
        </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
    container: { flex: 1, backgroundColor: '#1e1e1e' },
    header: { padding: 15, fontSize: 18, fontWeight: 'bold', color: '#fff', borderBottomWidth: 1, borderBottomColor: '#333' },
    item: { flexDirection: 'row', alignItems: 'center', padding: 15, borderBottomWidth: 1, borderBottomColor: '#2b2b2b' },
    itemName: { color: '#fff', fontSize: 16 },
    itemSub: { color: '#666', fontSize: 12 },
    fabContainer: { position: 'absolute', bottom: 20, right: 20, alignItems: 'flex-end' },
    fab: { width: 56, height: 56, borderRadius: 28, alignItems: 'center', justifyContent: 'center', elevation: 5 },
    menu: { marginBottom: 10, backgroundColor: '#333', borderRadius: 8, padding: 5, elevation: 5 },
    menuItem: { flexDirection: 'row', alignItems: 'center', padding: 10, minWidth: 150 },
    menuText: { color: '#fff', marginLeft: 10 },
    modalBg: { flex: 1, backgroundColor: 'rgba(0,0,0,0.7)', justifyContent: 'center', padding: 20 },
    modal: { backgroundColor: '#252526', padding: 20, borderRadius: 10 },
    modalTitle: { color: '#fff', fontSize: 18, marginBottom: 15, fontWeight: 'bold' },
    input: { backgroundColor: '#333', color: '#fff', padding: 10, borderRadius: 5, marginBottom: 10 },
    actions: { flexDirection: 'row', justifyContent: 'space-between', marginTop: 15 }
});


/* src/components/ConnectionError.js */

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Linking } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

export default function ConnectionError({ onRetry, serverUrl }) {
  const openTermux = () => Linking.openURL('termux://').catch(() => {});

  return (
    <View style={styles.container}>
      <MaterialCommunityIcons name="server-network-off" size={80} color="#ff4444" />
      <Text style={styles.title}>Server Disconnected</Text>
      <Text style={styles.desc}>
        Could not connect to {serverUrl}.{"\n"}
        Make sure you launched the server in Termux:
      </Text>
      <View style={styles.codeBlock}>
        <Text style={styles.code}>cd termux-ide</Text>
        <Text style={styles.code}>node server</Text>
      </View>
      
      <TouchableOpacity style={styles.btnPrimary} onPress={openTermux}>
        <Text style={styles.btnText}>Open Termux</Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={styles.btnSecondary} onPress={onRetry}>
        <Text style={styles.btnTextSec}>Retry Connection</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#1e1e1e', justifyContent: 'center', alignItems: 'center', padding: 20 },
  title: { color: '#fff', fontSize: 22, fontWeight: 'bold', marginTop: 20 },
  desc: { color: '#aaa', textAlign: 'center', marginTop: 10, lineHeight: 22 },
  codeBlock: { backgroundColor: '#000', padding: 15, borderRadius: 8, marginVertical: 20, width: '100%' },
  code: { color: '#00ff00', fontFamily: 'monospace' },
  btnPrimary: { backgroundColor: '#007acc', padding: 12, borderRadius: 6, width: '100%', alignItems: 'center', marginBottom: 10 },
  btnSecondary: { backgroundColor: '#333', padding: 12, borderRadius: 6, width: '100%', alignItems: 'center' },
  btnText: { color: '#fff', fontWeight: 'bold' },
  btnTextSec: { color: '#ccc' }
});


/* src/components/Toast.js */

/* src/components/Toast.js */
import React, { useEffect, useRef } from 'react';
import { Animated, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

export default function Toast({ message, type = 'info', onHide }) {
    const opacity = useRef(new Animated.Value(0)).current;
    const translateY = useRef(new Animated.Value(-50)).current;

    useEffect(() => {
        Animated.parallel([
            Animated.timing(opacity, { toValue: 1, duration: 300, useNativeDriver: true }),
            Animated.timing(translateY, { toValue: 50, duration: 300, useNativeDriver: true })
        ]).start();

        const timer = setTimeout(() => {
            hide();
        }, 3000);

        return () => clearTimeout(timer);
    }, []);

    const hide = () => {
        Animated.parallel([
            Animated.timing(opacity, { toValue: 0, duration: 300, useNativeDriver: true }),
            Animated.timing(translateY, { toValue: -50, duration: 300, useNativeDriver: true })
        ]).start(() => onHide && onHide());
    };

    let bg = '#333';
    let icon = 'information';
    if (type === 'error') { bg = '#b71c1c'; icon = 'alert-circle'; }
    if (type === 'success') { bg = '#2e7d32'; icon = 'check-circle'; }

    return (
        <Animated.View style={[styles.container, { opacity, transform: [{ translateY }], backgroundColor: bg }]}>
            <MaterialCommunityIcons name={icon} size={20} color="white" style={{marginRight: 10}} />
            <Text style={styles.text}>{message}</Text>
            <TouchableOpacity onPress={hide}>
                <MaterialCommunityIcons name="close" size={18} color="#ccc" />
            </TouchableOpacity>
        </Animated.View>
    );
}

const styles = StyleSheet.create({
    container: {
        position: 'absolute', top: 0, left: 20, right: 20,
        padding: 15, borderRadius: 8, flexDirection: 'row', alignItems: 'center',
        zIndex: 9999, elevation: 20, shadowColor: '#000', shadowOpacity: 0.3, shadowRadius: 5
    },
    text: { color: 'white', flex: 1, fontSize: 14 }
});


/* src/config/fileConfig.js */

// src/config/fileConfig.js

export const fileConfig = {
    // Расширения -> { icon: 'имя-в-material-icons', color: '#hex' }
    associations: {
        '.js':   { icon: 'language-javascript', color: '#f1e05a' },
        '.jsx':  { icon: 'react',               color: '#61dafb' },
        '.ts':   { icon: 'language-typescript', color: '#2b7489' },
        '.tsx':  { icon: 'react',               color: '#2b7489' },
        '.html': { icon: 'language-html5',      color: '#e34c26' },
        '.css':  { icon: 'language-css3',       color: '#563d7c' },
        '.scss': { icon: 'sass',                color: '#c6538c' },
        '.json': { icon: 'code-json',           color: '#cbcb41' },
        '.java': { icon: 'language-java',       color: '#b07219' },
        '.py':   { icon: 'language-python',     color: '#3572a5' },
        '.cpp':  { icon: 'language-cpp',        color: '#f34b7d' },
        '.c':    { icon: 'language-c',          color: '#555555' },
        '.xml':  { icon: 'xml',                 color: '#0060ac' },
        '.md':   { icon: 'language-markdown',   color: '#083fa1' },
        '.php':  { icon: 'language-php',        color: '#777bb4' },
        '.go':   { icon: 'language-go',         color: '#00add8' },
        '.sql':  { icon: 'database',            color: '#e38c00' },
        '.zip':  { icon: 'zip-box',             color: '#d9d9d9' },
        '.png':  { icon: 'image',               color: '#b83df2' },
        '.jpg':  { icon: 'image',               color: '#b83df2' },
        '.svg':  { icon: 'svg',                 color: '#ffb13b' },
        'default': { icon: 'file-document-outline', color: '#cccccc' }
    },

    // Точные имена файлов
    specificNames: {
        'package.json':      { icon: 'nodejs',      color: '#4caf50' },
        'package-lock.json': { icon: 'nodejs',      color: '#4caf50' },
        'tsconfig.json':     { icon: 'language-typescript', color: '#2b7489' },
        'readme.md':         { icon: 'information-outline', color: '#083fa1' },
        '.gitignore':        { icon: 'git',         color: '#f44d27' },
        '.env':              { icon: 'cog',         color: '#ecd53f' },
        'dockerfile':        { icon: 'docker',      color: '#384d54' },
    },

    // Папки
    folderIcons: {
        'src':           { icon: 'folder',       color: '#4caf50' }, // Зеленая
        'dist':          { icon: 'folder',       color: '#ff9800' }, // Оранжевая
        'node_modules':  { icon: 'folder-remove',color: '#cb3837' }, // Красная
        'assets':        { icon: 'folder-image', color: '#ffc107' },
        '.git':          { icon: 'git',          color: '#f44d27' },
        'android':       { icon: 'android',      color: '#3ddc84' },
        'ios':           { icon: 'apple',        color: '#999999' },
        'components':    { icon: 'shape',        color: '#00bcd4' },
        'default':       { icon: 'folder',       color: '#dcb67a' },
        'open':          { icon: 'folder-open',  color: '#dcb67a' }
    },

    getFileSettings: (filename) => {
        const lowerName = filename.toLowerCase();
        if (fileConfig.specificNames[lowerName]) return fileConfig.specificNames[lowerName];
        
        const parts = lowerName.split('.');
        if (parts.length > 1) {
            const ext = '.' + parts.pop();
            if (fileConfig.associations[ext]) return fileConfig.associations[ext];
        }
        return fileConfig.associations['default'];
    }
};


/* src/utils/logger.js */

import axios from 'axios';

const SERVER_URL = 'http://127.0.0.1:3000';

export const logToTermux = async (message, component = 'App') => {
    try {
        // Конвертируем объект в строку, если нужно
        const msg = typeof message === 'object' ? JSON.stringify(message) : String(message);
        console.log(`[${component}]`, msg); // Лог в Metro (для Expo)
        
        // Лог на сервер Termux
        await axios.post(`${SERVER_URL}/api/log-client-error`, {
            message: msg,
            component: component,
            stack: 'React Native Log'
        });
    } catch (e) {
        // Если сервер недоступен, просто пишем в консоль телефона
        console.warn('Failed to send log to Termux:', e.message);
    }
};


/* src/utils/fileHelpers.js */

/* src/utils/fileHelpers.js */
export const isBinaryFile = (filename) => {
    if (!filename) return false;
    const ext = filename.split('.').pop().toLowerCase();
    const binaryExts = [
        'png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp', 'ico',
        'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx',
        'zip', 'rar', '7z', 'tar', 'gz', 'apk', 'ipa',
        'mp3', 'wav', 'mp4', 'avi', 'mkv', 'mov',
        'eot', 'ttf', 'woff', 'woff2', 'class', 'dex', 'so'
    ];
    return binaryExts.includes(ext);
};


/* src/services/NativeService.js */

import { NativeModules, DeviceEventEmitter } from 'react-native';

const { XKodeNative } = NativeModules;

// Если модуль не найден (например в Expo Go), ставим заглушки чтобы не крашилось
const Native = XKodeNative || {
    listLocalFiles: () => Promise.reject("Native module not found"),
    readLocalFile: () => Promise.reject("Native module not found"),
    saveLocalFile: () => Promise.reject("Native module not found"),
    connectSSH: () => Promise.reject("Native module not found"),
    writeSSH: () => {},
    disconnectSSH: () => {},
    listSftpFiles: () => Promise.reject("Native module not found"),
};

export default {
    // --- FILES ---
    listLocal: (path) => Native.listLocalFiles(path),
    readLocal: (path) => Native.readLocalFile(path),
    saveLocal: (path, content) => Native.saveLocalFile(path, content),

    // --- SFTP ---
    // Передаем креды каждый раз, так как Java модуль stateless в этом примере
    listSftp: (config, path) => Native.listSftpFiles(
        config.host, 
        parseInt(config.port), 
        config.username, 
        config.password, 
        path
    ),

    // --- SSH ---
    connectSSH: (host, port, username, password) => Native.connectSSH(host, parseInt(port), username, password),
    writeSSH: (command) => Native.writeSSH(command),
    disconnectSSH: () => Native.disconnectSSH(),
    
    // События (вывод терминала)
    onSSHOutput: (callback) => DeviceEventEmitter.addListener('SSH_OUTPUT', callback)
};


/* android/.gitignore */

# OSX
#
.DS_Store

# Android/IntelliJ
#
build/
.idea
.gradle
local.properties
*.iml
*.hprof
.cxx/

# Bundle artifacts
*.jsbundle


/* android/settings.gradle */

pluginManagement {
  def reactNativeGradlePlugin = new File(
    providers.exec {
      workingDir(rootDir)
      commandLine("node", "--print", "require.resolve('@react-native/gradle-plugin/package.json', { paths: [require.resolve('react-native/package.json')] })")
    }.standardOutput.asText.get().trim()
  ).getParentFile().absolutePath
  includeBuild(reactNativeGradlePlugin)
  
  def expoPluginsPath = new File(
    providers.exec {
      workingDir(rootDir)
      commandLine("node", "--print", "require.resolve('expo-modules-autolinking/package.json', { paths: [require.resolve('expo/package.json')] })")
    }.standardOutput.asText.get().trim(),
    "../android/expo-gradle-plugin"
  ).absolutePath
  includeBuild(expoPluginsPath)
}

plugins {
  id("com.facebook.react.settings")
  id("expo-autolinking-settings")
}

extensions.configure(com.facebook.react.ReactSettingsExtension) { ex ->
  if (System.getenv('EXPO_USE_COMMUNITY_AUTOLINKING') == '1') {
    ex.autolinkLibrariesFromCommand()
  } else {
    ex.autolinkLibrariesFromCommand(expoAutolinking.rnConfigCommand)
  }
}
expoAutolinking.useExpoModules()

rootProject.name = 'XKode'

expoAutolinking.useExpoVersionCatalog()

include ':app'
includeBuild(expoAutolinking.reactNativeGradlePlugin)


/* android/app/build.gradle */

apply plugin: "com.android.application"
apply plugin: "org.jetbrains.kotlin.android"
apply plugin: "com.facebook.react"

def projectRoot = rootDir.getAbsoluteFile().getParentFile().getAbsolutePath()

/**
 * This is the configuration block to customize your React Native Android app.
 * By default you don't need to apply any configuration, just uncomment the lines you need.
 */
react {
    entryFile = file(["node", "-e", "require('expo/scripts/resolveAppEntry')", projectRoot, "android", "absolute"].execute(null, rootDir).text.trim())
    reactNativeDir = new File(["node", "--print", "require.resolve('react-native/package.json')"].execute(null, rootDir).text.trim()).getParentFile().getAbsoluteFile()
    hermesCommand = new File(["node", "--print", "require.resolve('react-native/package.json')"].execute(null, rootDir).text.trim()).getParentFile().getAbsolutePath() + "/sdks/hermesc/%OS-BIN%/hermesc"
    codegenDir = new File(["node", "--print", "require.resolve('@react-native/codegen/package.json', { paths: [require.resolve('react-native/package.json')] })"].execute(null, rootDir).text.trim()).getParentFile().getAbsoluteFile()

    enableBundleCompression = (findProperty('android.enableBundleCompression') ?: false).toBoolean()
    // Use Expo CLI to bundle the app, this ensures the Metro config
    // works correctly with Expo projects.
    cliFile = new File(["node", "--print", "require.resolve('@expo/cli', { paths: [require.resolve('expo/package.json')] })"].execute(null, rootDir).text.trim())
    bundleCommand = "export:embed"

    /* Folders */
     //   The root of your project, i.e. where "package.json" lives. Default is '../..'
    // root = file("../../")
    //   The folder where the react-native NPM package is. Default is ../../node_modules/react-native
    // reactNativeDir = file("../../node_modules/react-native")
    //   The folder where the react-native Codegen package is. Default is ../../node_modules/@react-native/codegen
    // codegenDir = file("../../node_modules/@react-native/codegen")

    /* Variants */
    //   The list of variants to that are debuggable. For those we're going to
    //   skip the bundling of the JS bundle and the assets. By default is just 'debug'.
    //   If you add flavors like lite, prod, etc. you'll have to list your debuggableVariants.
    // debuggableVariants = ["liteDebug", "prodDebug"]

    /* Bundling */
    //   A list containing the node command and its flags. Default is just 'node'.
    // nodeExecutableAndArgs = ["node"]

    //
    //   The path to the CLI configuration file. Default is empty.
    // bundleConfig = file(../rn-cli.config.js)
    //
    //   The name of the generated asset file containing your JS bundle
    // bundleAssetName = "MyApplication.android.bundle"
    //
    //   The entry file for bundle generation. Default is 'index.android.js' or 'index.js'
    // entryFile = file("../js/MyApplication.android.js")
    //
    //   A list of extra flags to pass to the 'bundle' commands.
    //   See https://github.com/react-native-community/cli/blob/main/docs/commands.md#bundle
    // extraPackagerArgs = []

    /* Hermes Commands */
    //   The hermes compiler command to run. By default it is 'hermesc'
    // hermesCommand = "$rootDir/my-custom-hermesc/bin/hermesc"
    //
    //   The list of flags to pass to the Hermes compiler. By default is "-O", "-output-source-map"
    // hermesFlags = ["-O", "-output-source-map"]

    /* Autolinking */
    autolinkLibrariesWithApp()
}

/**
 * Set this to true in release builds to optimize the app using [R8](https://developer.android.com/topic/performance/app-optimization/enable-app-optimization).
 */
def enableMinifyInReleaseBuilds = (findProperty('android.enableMinifyInReleaseBuilds') ?: false).toBoolean()

/**
 * The preferred build flavor of JavaScriptCore (JSC)
 *
 * For example, to use the international variant, you can use:
 * `def jscFlavor = 'org.webkit:android-jsc-intl:+'`
 *
 * The international variant includes ICU i18n library and necessary data
 * allowing to use e.g. `Date.toLocaleString` and `String.localeCompare` that
 * give correct results when using with locales other than en-US. Note that
 * this variant is about 6MiB larger per architecture than default.
 */
def jscFlavor = 'io.github.react-native-community:jsc-android:2026004.+'

android {
    ndkVersion rootProject.ext.ndkVersion

    buildToolsVersion rootProject.ext.buildToolsVersion
    compileSdk rootProject.ext.compileSdkVersion

    namespace 'pro.kaleert.XKode'
    defaultConfig {
        applicationId 'pro.kaleert.XKode'
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0.0"

        buildConfigField "String", "REACT_NATIVE_RELEASE_LEVEL", "\"${findProperty('reactNativeReleaseLevel') ?: 'stable'}\""
    }
    signingConfigs {
        debug {
            storeFile file('debug.keystore')
            storePassword 'android'
            keyAlias 'androiddebugkey'
            keyPassword 'android'
        }
    }
    buildTypes {
        debug {
            signingConfig signingConfigs.debug
        }
        release {
            // Caution! In production, you need to generate your own keystore file.
            // see https://reactnative.dev/docs/signed-apk-android.
            signingConfig signingConfigs.debug
            def enableShrinkResources = findProperty('android.enableShrinkResourcesInReleaseBuilds') ?: 'false'
            shrinkResources enableShrinkResources.toBoolean()
            minifyEnabled enableMinifyInReleaseBuilds
            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
            def enablePngCrunchInRelease = findProperty('android.enablePngCrunchInReleaseBuilds') ?: 'true'
            crunchPngs enablePngCrunchInRelease.toBoolean()
        }
    }
    packagingOptions {
        jniLibs {
            def enableLegacyPackaging = findProperty('expo.useLegacyPackaging') ?: 'false'
            useLegacyPackaging enableLegacyPackaging.toBoolean()
        }
    }
    androidResources {
        ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:!CVS:!thumbs.db:!picasa.ini:!*~'
    }
}

// Apply static values from `gradle.properties` to the `android.packagingOptions`
// Accepts values in comma delimited lists, example:
// android.packagingOptions.pickFirsts=/LICENSE,**/picasa.ini
["pickFirsts", "excludes", "merges", "doNotStrip"].each { prop ->
    // Split option: 'foo,bar' -> ['foo', 'bar']
    def options = (findProperty("android.packagingOptions.$prop") ?: "").split(",");
    // Trim all elements in place.
    for (i in 0..<options.size()) options[i] = options[i].trim();
    // `[] - ""` is essentially `[""].filter(Boolean)` removing all empty strings.
    options -= ""

    if (options.length > 0) {
        println "android.packagingOptions.$prop += $options ($options.length)"
        // Ex: android.packagingOptions.pickFirsts += '**/SCCS/**'
        options.each {
            android.packagingOptions[prop] += it
        }
    }
}

dependencies {
    implementation 'com.jcraft:jsch:0.1.55'
    
    // The version of react-native is set by the React Native Gradle Plugin
    implementation("com.facebook.react:react-android")

    def isGifEnabled = (findProperty('expo.gif.enabled') ?: "") == "true";
    def isWebpEnabled = (findProperty('expo.webp.enabled') ?: "") == "true";
    def isWebpAnimatedEnabled = (findProperty('expo.webp.animated') ?: "") == "true";

    if (isGifEnabled) {
        // For animated gif support
        implementation("com.facebook.fresco:animated-gif:${expoLibs.versions.fresco.get()}")
    }

    if (isWebpEnabled) {
        // For webp support
        implementation("com.facebook.fresco:webpsupport:${expoLibs.versions.fresco.get()}")
        if (isWebpAnimatedEnabled) {
            // Animated webp support
            implementation("com.facebook.fresco:animated-webp:${expoLibs.versions.fresco.get()}")
        }
    }

    if (hermesEnabled.toBoolean()) {
        implementation("com.facebook.react:hermes-android")
    } else {
        implementation jscFlavor
    }
}


/* android/app/proguard-rules.pro */

# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in /usr/local/Cellar/android-sdk/24.3.3/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the proguardFiles
# directive in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# react-native-reanimated
-keep class com.swmansion.reanimated.** { *; }
-keep class com.facebook.react.turbomodule.** { *; }

# Add any project specific keep options here:


/* android/app/src/main/AndroidManifest.xml */

<manifest xmlns:android="http://schemas.android.com/apk/res/android">
  <uses-permission android:name="android.permission.INTERNET"/>
  <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE"/>
  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
  <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>
  <uses-permission android:name="android.permission.VIBRATE"/>
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
  <queries>
    <intent>
      <action android:name="android.intent.action.VIEW"/>
      <category android:name="android.intent.category.BROWSABLE"/>
      <data android:scheme="https"/>
    </intent>
  </queries>
  <application android:name=".MainApplication" android:label="@string/app_name" android:icon="@mipmap/ic_launcher" android:roundIcon="@mipmap/ic_launcher_round" android:allowBackup="true" android:theme="@style/AppTheme" android:supportsRtl="true" android:enableOnBackInvokedCallback="false" android:usesCleartextTraffic="true">
    <meta-data android:name="expo.modules.updates.ENABLED" android:value="false"/>
    <meta-data android:name="expo.modules.updates.EXPO_UPDATES_CHECK_ON_LAUNCH" android:value="ALWAYS"/>
    <meta-data android:name="expo.modules.updates.EXPO_UPDATES_LAUNCH_WAIT_MS" android:value="0"/>
    <activity android:name=".MainActivity" android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|uiMode" android:launchMode="singleTask" android:windowSoftInputMode="adjustResize" android:theme="@style/Theme.App.SplashScreen" android:exported="true" android:screenOrientation="portrait">
      <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
      </intent-filter>
      <intent-filter>
        <action android:name="android.intent.action.VIEW"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="android.intent.category.BROWSABLE"/>
        <data android:scheme="termuxidenative"/>
      </intent-filter>
    </activity>
  </application>
</manifest>


/* android/app/src/main/java/pro/kaleert/XKode/MainApplication.kt */

package pro.kaleert.XKode

import android.app.Application
import android.content.res.Configuration

import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactNativeApplicationEntryPoint.loadReactNative
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.ReactHost
import com.facebook.react.common.ReleaseLevel
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint
import com.facebook.react.defaults.DefaultReactNativeHost

import expo.modules.ApplicationLifecycleDispatcher
import expo.modules.ReactNativeHostWrapper

import pro.kaleert.XKode.XKodePackage

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost = ReactNativeHostWrapper(
      this,
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List<ReactPackage> {
            val packages = PackageList(this).packages.toMutableList()
            packages.add(XKodePackage())
            return packages
        }

          override fun getJSMainModuleName(): String = ".expo/.virtual-metro-entry"

          override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

          override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
      }
  )

  override val reactHost: ReactHost
    get() = ReactNativeHostWrapper.createReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    DefaultNewArchitectureEntryPoint.releaseLevel = try {
      ReleaseLevel.valueOf(BuildConfig.REACT_NATIVE_RELEASE_LEVEL.uppercase())
    } catch (e: IllegalArgumentException) {
      ReleaseLevel.STABLE
    }
    loadReactNative(this)
    ApplicationLifecycleDispatcher.onApplicationCreate(this)
  }

  override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    ApplicationLifecycleDispatcher.onConfigurationChanged(this, newConfig)
  }
}


/* android/app/src/main/java/pro/kaleert/XKode/MainActivity.kt */

package pro.kaleert.XKode
import expo.modules.splashscreen.SplashScreenManager

import android.os.Build
import android.os.Bundle

import com.facebook.react.ReactActivity
import com.facebook.react.ReactActivityDelegate
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.fabricEnabled
import com.facebook.react.defaults.DefaultReactActivityDelegate

import expo.modules.ReactActivityDelegateWrapper

class MainActivity : ReactActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    // Set the theme to AppTheme BEFORE onCreate to support
    // coloring the background, status bar, and navigation bar.
    // This is required for expo-splash-screen.
    // setTheme(R.style.AppTheme);
    // @generated begin expo-splashscreen - expo prebuild (DO NOT MODIFY) sync-f3ff59a738c56c9a6119210cb55f0b613eb8b6af
    SplashScreenManager.registerOnActivity(this)
    // @generated end expo-splashscreen
    super.onCreate(null)
  }

  /**
   * Returns the name of the main component registered from JavaScript. This is used to schedule
   * rendering of the component.
   */
  override fun getMainComponentName(): String = "main"

  /**
   * Returns the instance of the [ReactActivityDelegate]. We use [DefaultReactActivityDelegate]
   * which allows you to enable New Architecture with a single boolean flags [fabricEnabled]
   */
  override fun createReactActivityDelegate(): ReactActivityDelegate {
    return ReactActivityDelegateWrapper(
          this,
          BuildConfig.IS_NEW_ARCHITECTURE_ENABLED,
          object : DefaultReactActivityDelegate(
              this,
              mainComponentName,
              fabricEnabled
          ){})
  }

  /**
    * Align the back button behavior with Android S
    * where moving root activities to background instead of finishing activities.
    * @see <a href="https://developer.android.com/reference/android/app/Activity#onBackPressed()">onBackPressed</a>
    */
  override fun invokeDefaultOnBackPressed() {
      if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.R) {
          if (!moveTaskToBack(false)) {
              // For non-root activities, use the default implementation to finish them.
              super.invokeDefaultOnBackPressed()
          }
          return
      }

      // Use the default back button implementation on Android S
      // because it's doing more than [Activity.moveTaskToBack] in fact.
      super.invokeDefaultOnBackPressed()
  }
}


/* android/app/src/main/java/pro/kaleert/XKode/XKodeModule.java */

package pro.kaleert.XKode;

import android.os.Environment;
import android.util.Log;

import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.modules.core.DeviceEventManagerModule;

import com.jcraft.jsch.Channel;
import com.jcraft.jsch.ChannelExec;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.ChannelShell;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.Session;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.Properties;
import java.util.Vector;

public class XKodeModule extends ReactContextBaseJavaModule {
    private static ReactApplicationContext reactContext;
    private Session sshSession;
    private ChannelShell sshChannel;
    private OutputStream sshOutputStream;

    public XKodeModule(ReactApplicationContext context) {
        super(context);
        reactContext = context;
    }

    @Override
    public String getName() {
        return "XKodeNative";
    }

    // --- LOCAL FILE SYSTEM ---

    @ReactMethod
    public void listLocalFiles(String path, Promise promise) {
        try {
            File directory;
            if (path == null || path.equals("/") || path.isEmpty()) {
                directory = Environment.getExternalStorageDirectory(); // /storage/emulated/0
            } else {
                directory = new File(path);
            }

            if (!directory.exists() || !directory.isDirectory()) {
                promise.reject("ERROR", "Path is not a directory or doesn't exist");
                return;
            }

            File[] files = directory.listFiles();
            WritableArray result = Arguments.createArray();

            if (files != null) {
                for (File file : files) {
                    WritableMap fileMap = Arguments.createMap();
                    fileMap.putString("name", file.getName());
                    fileMap.putString("path", file.getAbsolutePath());
                    fileMap.putBoolean("isDirectory", file.isDirectory());
                    result.pushMap(fileMap);
                }
            }
            promise.resolve(result);
        } catch (Exception e) {
            promise.reject("ERROR", e.getMessage());
        }
    }

    @ReactMethod
    public void readLocalFile(String path, Promise promise) {
        try {
            File file = new File(path);
            FileInputStream fis = new FileInputStream(file);
            byte[] data = new byte[(int) file.length()];
            fis.read(data);
            fis.close();
            String content = new String(data, StandardCharsets.UTF_8);
            promise.resolve(content);
        } catch (Exception e) {
            promise.reject("ERROR", e.getMessage());
        }
    }

    @ReactMethod
    public void saveLocalFile(String path, String content, Promise promise) {
        try {
            FileOutputStream fos = new FileOutputStream(new File(path));
            fos.write(content.getBytes(StandardCharsets.UTF_8));
            fos.close();
            promise.resolve("Saved");
        } catch (Exception e) {
            promise.reject("ERROR", e.getMessage());
        }
    }

    // --- SFTP SECTION ---
    // (Упрощенно, создает новую сессию на каждый запрос. Для продакшена лучше держать пул)

    private Session getSftpSession(String host, int port, String user, String password) throws Exception {
        JSch jsch = new JSch();
        Session session = jsch.getSession(user, host, port);
        session.setPassword(password);
        Properties config = new Properties();
        config.put("StrictHostKeyChecking", "no");
        session.setConfig(config);
        session.connect(5000);
        return session;
    }

    @ReactMethod
    public void listSftpFiles(String host, int port, String user, String password, String path, Promise promise) {
        new Thread(() -> {
            Session session = null;
            ChannelSftp channel = null;
            try {
                session = getSftpSession(host, port, user, password);
                channel = (ChannelSftp) session.openChannel("sftp");
                channel.connect();

                Vector<ChannelSftp.LsEntry> list = channel.ls(path);
                WritableArray result = Arguments.createArray();

                for (ChannelSftp.LsEntry entry : list) {
                    if (entry.getFilename().equals(".") || entry.getFilename().equals("..")) continue;
                    WritableMap map = Arguments.createMap();
                    map.putString("name", entry.getFilename());
                    map.putString("path", path + "/" + entry.getFilename()); // Crude path join
                    map.putBoolean("isDirectory", entry.getAttrs().isDir());
                    result.pushMap(map);
                }
                promise.resolve(result);

            } catch (Exception e) {
                promise.reject("SFTP_ERROR", e.getMessage());
            } finally {
                if (channel != null) channel.disconnect();
                if (session != null) session.disconnect();
            }
        }).start();
    }

    // --- SSH TERMINAL (Connect to Termux or Server) ---

    @ReactMethod
    public void connectSSH(String host, int port, String user, String password, Promise promise) {
        new Thread(() -> {
            try {
                if (sshSession != null && sshSession.isConnected()) {
                    sshSession.disconnect();
                }

                JSch jsch = new JSch();
                sshSession = jsch.getSession(user, host, port);
                sshSession.setPassword(password);
                Properties config = new Properties();
                config.put("StrictHostKeyChecking", "no");
                sshSession.setConfig(config);
                sshSession.connect(10000);

                // Открываем Shell канал
                sshChannel = (ChannelShell) sshSession.openChannel("shell");
                sshChannel.setPty(true); // Важно для интерактивности

                InputStream in = sshChannel.getInputStream();
                sshOutputStream = sshChannel.getOutputStream();

                sshChannel.connect();

                promise.resolve("Connected");

                // Читаем поток в отдельном треде и шлем в React Native
                byte[] buffer = new byte[1024];
                int i;
                while ((i = in.read(buffer)) != -1) {
                    String line = new String(buffer, 0, i, StandardCharsets.UTF_8);
                    sendEvent("SSH_OUTPUT", line);
                }

            } catch (Exception e) {
                promise.reject("SSH_ERROR", e.getMessage());
                sendEvent("SSH_OUTPUT", "\r\nConnection Failed: " + e.getMessage() + "\r\n");
            }
        }).start();
    }

    @ReactMethod
    public void writeSSH(String command) {
        if (sshOutputStream != null) {
            try {
                sshOutputStream.write(command.getBytes(StandardCharsets.UTF_8));
                sshOutputStream.flush();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    @ReactMethod
    public void disconnectSSH() {
        if (sshChannel != null) sshChannel.disconnect();
        if (sshSession != null) sshSession.disconnect();
    }

    private void sendEvent(String eventName, String data) {
        reactContext
                .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
                .emit(eventName, data);
    }
}


/* android/app/src/main/java/pro/kaleert/XKode/XKodePackage.java */

package pro.kaleert.XKode;

import com.facebook.react.ReactPackage;
import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.uimanager.ViewManager;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class XKodePackage implements ReactPackage {
    @Override
    public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {
        return Collections.emptyList();
    }

    @Override
    public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {
        List<NativeModule> modules = new ArrayList<>();
        modules.add(new XKodeModule(reactContext));
        return modules;
    }
}


/* android/app/src/assets/www/terminal.html */

<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background: #1e1e1e; overflow: hidden; }
        #terminal { width: 100vw; height: 100vh; }
        /* Шрифт как в Termux */
        .xterm-rows { 
            font-family: monospace, 'Courier New' !important; 
            font-size: 14px !important; 
        }
    </style>
    
    <!-- Подключение локальных файлов -->
    <link rel="stylesheet" href="./xterm/xterm.css" />
    <script src="./xterm/xterm.js"></script>
    <script src="./xterm/xterm-addon-fit.js"></script>
</head>
<body>
    <div id="terminal"></div>
    
    <script>
        // Проверка, что файлы загрузились
        if (typeof Terminal === 'undefined') {
            document.body.innerHTML = '<h3 style="color:red">Error: xterm.js not loaded. Check assets path.</h3>';
        }

        var term = new Terminal({
            fontFamily: 'monospace', 
            fontSize: 14, 
            cursorBlink: true,
            theme: { background: '#1e1e1e', selection: '#264f78', cursor: '#007acc' },
            allowProposedApi: true
        });

        var fit = new FitAddon.FitAddon();
        term.loadAddon(fit);
        term.open(document.getElementById('terminal'));
        
        // Небольшая задержка для корректного расчета размеров
        setTimeout(function() {
            fit.fit();
        }, 100);

        window.term = term;

        // Перехват ввода (если печатаем прямо в терминал)
        // Для отправки используем window.ReactNativeWebView (стандарт для React Native WebView)
        term.onData(function(data) {
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({type: 'input', data: data}));
            }
        });

        // Адаптация при повороте экрана
        window.addEventListener('resize', function() {
            fit.fit();
        });
    </script>
</body>
</html>


/* android/app/src/assets/www/editor.html */

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #1e1e1e; }
        #container { width: 100vw; height: 100vh; }
        /* Отступ снизу для скролла */
        .monaco-editor .lines-content { padding-bottom: 50vh !important; }
    </style>
    
    <!-- Локальный загрузчик Monaco -->
    <script src="./monaco/vs/loader.js"></script>
</head>
<body>
    <div id="container"></div>
    
    <script>
        // Настройка путей для Monaco (относительно этого HTML файла)
        require.config({ paths: { 'vs': './monaco/vs' }});

        require(['vs/editor/editor.main'], function() {
            window.editor = monaco.editor.create(document.getElementById('container'), {
                value: "", // Пусто при инициализации
                language: 'javascript',
                theme: 'vs-dark',
                automaticLayout: true,
                minimap: { enabled: false }, // На телефоне мешает
                fontSize: 14,
                lineNumbers: 'on',
                lineNumbersMinChars: 3,
                glyphMargin: false,
                folding: true,
                scrollBeyondLastLine: false,
                wordWrap: 'off', // Без переноса строк
                scrollbar: {
                    verticalScrollbarSize: 12,
                    horizontalScrollbarSize: 12
                }
            });

            // Слушаем сообщения от React Native (Native -> WebView)
            var handleMessage = function(event) {
                try {
                    var data = JSON.parse(event.data);
                    
                    if (data.type === 'setCode') {
                         var model = window.editor.getModel();
                         
                         // Простое определение языка по расширению
                         var ext = data.path ? data.path.split('.').pop() : 'js';
                         var lang = 'javascript';
                         if(ext === 'html') lang = 'html';
                         if(ext === 'css') lang = 'css';
                         if(ext === 'json') lang = 'json';
                         if(ext === 'java') lang = 'java';
                         if(ext === 'py') lang = 'python';
                         if(ext === 'cpp' || ext === 'c' || ext === 'h') lang = 'cpp';
                         if(ext === 'xml') lang = 'xml';
                         if(ext === 'md') lang = 'markdown';
                         
                         monaco.editor.setModelLanguage(model, lang);
                         window.editor.setValue(data.content);
                    }
                } catch(e) {
                    // console.error(e);
                }
            };

            // Поддержка разных платформ (Android/iOS иногда по-разному шлют события)
            document.addEventListener("message", handleMessage);
            window.addEventListener("message", handleMessage);
        });

        // Методы для вызова из React Native (WebView -> Native)
        window.requestSave = function() {
            if (window.editor && window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'save',
                    content: window.editor.getValue()
                }));
            }
        };
        
        // Вставка текста с виртуальной клавиатуры
        window.insertText = function(text) {
            if (window.editor) {
                var selection = window.editor.getSelection();
                var op = {identifier: {major:1, minor:1}, range: selection, text: text, forceMoveMarkers: true};
                window.editor.executeEdits("my-source", [op]);
                window.editor.focus();
            }
        };
    </script>
</body>
</html>


/* android/.gradle/8.14.3/gc.properties */



/* android/.gradle/buildOutputCleanup/cache.properties */

#Sun Jan 04 16:33:33 GMT 2026
gradle.version=8.14.3


/* android/.gradle/vcs-1/gc.properties */

